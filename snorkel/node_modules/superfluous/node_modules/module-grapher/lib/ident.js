function _getTerms(identifier) {
  return identifier.split('/').filter(function(t) { return t; })
}

var TERM_REGEXP = /^([a-zA-Z0-9-_$]+|\.\.?)$/;

exports.isValid = isValid;
function isValid(identifier) {
  return _getTerms(identifier).every(function(term) {
    return TERM_REGEXP.test(term);
  });
}

exports.isRelative = isRelative;
function isRelative(identifier) {
  return (/^\.\.?$/).test(_getTerms(identifier)[0]);
}

exports.isTopLevel = isTopLevel;
function isTopLevel(identifier) {
  return !isRelative(identifier);
}

function getDirTerms(isDir) {
  var terms = this.terms,
      length = isDir ? terms.length : terms.length - 1;
  return terms.slice(0, length);
}


  exports.resolve = resolve;
  function resolve(otherIdentifier, isDir) {
    if (this.isTopLevel()) {
      return this.clone();
    }

    var otherTerms = otherIdentifier ? otherIdentifier.getDirTerms(isDir) : [],
        terms = this.resolveTerms(otherTerms);
    return createIdentifier(terms);
  }

  exports.resolveTerms = resolveTerms;
  function resolveTerms(terms) {
    var output = [], term;
    if (terms && this.isRelative()) {
      terms = terms.slice(0);
    } else {
      terms = [];
    }
    terms.push.apply(terms, this.terms);
    for (var i = 0, length = terms.length; i < length; i++) {
      term = terms[i];
      switch (term) {
        case '':
        case '.':
          continue;
        case '..':
          if (output.length) {
            output.pop();
          } else {
            throw new RangeError('Out of bounds identifier: ' + this);
          }
          break;
        default:
          output.push(term);
      }
    }
    return output;
  }





exports.fromDirIdentifier = fromDirIdentifier;
function fromDirIdentifier(ident) {
  var terms = ident.toArray();
  terms.push('index');
  return createIdentifier(terms);
}